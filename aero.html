<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aero Fighters ‚Äì Mini (Power‚ÄëUps + Win Screen)</title>
  <style>
    :root{ --bg:#ffbcbc; --ui:#d47272; --text:#e6f2ff; --hud:#0a1430; }
    html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial}
    body{display:grid;place-items:center;background:radial-gradient(1200px 800px at 50% 120%, #ff5c5c 0%, var(--bg) 60%); animation: fadeIn 2s ease-in-out forwards;}
    @keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}
    canvas{background:linear-gradient(#ff82bc,#ff44ab);border:2px solid var(--ui);border-radius:10px;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .hint{position:fixed;bottom:10px;left:50%;transform:translateX(-50%);color:#bcd;background:rgba(48, 17, 36, 0.55);border:1px solid #ff79c3;padding:6px 10px;border-radius:8px;font-size:12px}
    .winbtn{position:fixed;left:50%;top:56%;transform:translate(-50%,-50%);padding:12px 18px;border-radius:10px;border:1px solid #ff008c;background:linear-gradient(#ff82bc,#ff44ab);color:#eaf5ff;font-weight:800;text-decoration:none;letter-spacing:.3px;box-shadow:0 10px 25px rgba(0,0,0,.35);display:none}
    .winbtn.show{display:inline-block}
    
  </style>
</head>
<body>
  <canvas id="game" width="480" height="720" aria-label="Juego tipo Aero Fighters"></canvas>
  <div class="hint">WASD/‚Üê‚Üë‚Üí‚Üì para mover, Espacio para disparar, R reinicia. Power‚Äëups activos arriba a la derecha.</div>

  <script>
  /*
   * ‚úàÔ∏è Aero Fighters ‚Äì Mini (con power‚Äëups, balas y sonidos personalizables + pantalla de victoria)
   *
   * üîí Personalizaci√≥n por ‚Äúbackend‚Äù:
   *   - Todo se carga desde /config.json (o la URL que definas) y no hay panel visible.
   *   - Si quieres ocultar assets de Network, sirve URLs firmadas o tras un endpoint protegido.
   *
   * Gana al llegar a 2500 puntos: se muestra el avi√≥n del jugador en grande, el texto "¬°Lo lograste!"
   * y un bot√≥n para ir a otro HTML.
   */

  const C = document.getElementById('game');
  const ctx = C.getContext('2d');
  const W = C.width, H = C.height;

  // --- Default/fallback config (por si falla cargar config.json) ---
  const DEFAULTS = {
    player:{hp:3,speed:280,fireRate:220, image:null, bullet:{image:null,speed:520,sound:null}, deathSound:null},
    enemies:[
      {type:'A',image:null,hp:1,speed:90, fire:false, score:50,  bullet:{image:null,speed:180,sound:null}, deathSound:null},
      {type:'B',image:null,hp:1,speed:120,fire:true,  score:75,  bullet:{image:null,speed:200,sound:null}, deathSound:null},
      {type:'C',image:null,hp:3,speed:60, fire:true,  score:150, bullet:{image:null,speed:220,sound:null}, deathSound:null}
    ],
    powerUps:[
      {type:'rapid', image:null, duration:8000},
      {type:'spread',image:null, duration:8000},
      {type:'shield',image:null, duration:6000},
      {type:'heal',  image:null, amount:1}
    ],
    spawn:{enemyInterval:900, powerUpInterval:6000, maxEnemies:20},
    background:{stars:120}
  };

  const CONFIG = JSON.parse(JSON.stringify(DEFAULTS)); // clone

  // --- helpers ---
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  function setTimer(obj,key,dur,off){ clearTimeout(obj.powerTimers?.[key]); if(!obj.powerTimers) obj.powerTimers={}; obj.powerTimers[key]=setTimeout(off, dur); }
  function loadImage(url){ return new Promise(res=>{ if(!url){res(null);return;} const i=new Image(); i.crossOrigin='anonymous'; i.onload=()=>res(i); i.onerror=()=>res(null); i.src=url; }); }
  function loadSound(url){ return new Promise(res=>{ if(!url){res(null);return;} const a=new Audio(); a.src=url; a.preload='auto'; a.addEventListener('canplaythrough',()=>res(a),{once:true}); a.addEventListener('error',()=>res(null),{once:true}); }); }
  function play(sound){ if(sound){ try{ sound.currentTime=0; sound.play(); }catch(e){} } }

  async function applyConfigFromBackend(){
    try{
      const r = await fetch('./config.json', {cache:'no-store'});
      if(r.ok){
        const data = await r.json();
        Object.assign(CONFIG.player, data.player||{});
        if(Array.isArray(data.enemies)) CONFIG.enemies = data.enemies.map((e,i)=>Object.assign({}, DEFAULTS.enemies[i]||DEFAULTS.enemies[0], e));
        if(Array.isArray(data.powerUps)) CONFIG.powerUps = data.powerUps.map(p=>Object.assign({}, p));
        Object.assign(CONFIG.spawn, data.spawn||{});
        Object.assign(CONFIG.background, data.background||{});
        CONFIG.music         = data.music         || CONFIG.music;
CONFIG.musicVictory  = data.musicVictory  || CONFIG.musicVictory;
      }
    }catch(e){ /* fallback DEFAULTS */ }

    // Preload
    const loaders=[];
    loaders.push(loadImage(CONFIG.player.image).then(img=>{CONFIG.player.image=img;}));
    loaders.push(loadImage(CONFIG.player.bullet && CONFIG.player.bullet.image).then(img=>{ if(CONFIG.player.bullet) CONFIG.player.bullet.image=img; }));
    loaders.push(loadSound(CONFIG.player.bullet && CONFIG.player.bullet.sound).then(a=>{ if(CONFIG.player.bullet) CONFIG.player.bullet.sound=a; }));
    loaders.push(loadSound(CONFIG.player.deathSound).then(a=>{ CONFIG.player.deathSound=a; }));

    CONFIG.enemies.forEach(e=>{
      loaders.push(loadImage(e.image).then(img=>{ e.image=img; }));
      loaders.push(loadImage(e.bullet && e.bullet.image).then(img=>{ if(e.bullet) e.bullet.image=img; }));
      loaders.push(loadSound(e.bullet && e.bullet.sound).then(a=>{ if(e.bullet) e.bullet.sound=a; }));
      loaders.push(loadSound(e.deathSound).then(a=>{ e.deathSound=a; }));
    });

    CONFIG.powerUps.forEach(p=>{ loaders.push(loadImage(p.image).then(img=>{ p.image=img; })); });

    await Promise.all(loaders);
  }
// ===== M√∫sica de fondo / victoria / game over =====
let bgMusic = null;

function playMusic(cfg) {
  if (!cfg || !cfg.url) return null;
  const a = new Audio(cfg.url);
  a.loop = !!cfg.loop;
  a.volume = cfg.volume ?? 0.5;
  a.play().catch(()=>{}); // por si el navegador bloquea autoplay
  return a;
}

async function playBackgroundMusic() {
  if (!CONFIG.music || !CONFIG.music.url) return;
  if (!bgMusic) bgMusic = new Audio(CONFIG.music.url);
  bgMusic.loop = CONFIG.music.loop !== false;
  bgMusic.volume = CONFIG.music.volume ?? 0.5;
  try {
    await bgMusic.play();
  } catch (e) {
    // Requiere interacci√≥n del usuario (clic/tecla)
    const kick = () => bgMusic.play().catch(()=>{});
    document.body.addEventListener('click', kick, { once: true });
    document.body.addEventListener('keydown', kick, { once: true });
  }
}

  // ========= Entities =========
  class Entity{ constructor(x,y,w,h){ this.x=x; this.y=y; this.w=w; this.h=h; this.dead=false; } get cx(){return this.x+this.w/2} get cy(){return this.y+this.h/2} intersects(o){return !(this.x+this.w<o.x||this.x>o.x+o.w||this.y+this.h<o.y||this.y>o.y+o.h)} }

  class Player extends Entity{
    constructor(){ super(W/2-20,H-110,40,48); this.resetStats(); this.lastShot=0; this.shieldUntil=0; this.powerTimers={}; }
    resetStats(){ this.hp = CONFIG.player.hp||3; this.speed = CONFIG.player.speed||280; this.baseFireRate = CONFIG.player.fireRate||220; this.fireRate=this.baseFireRate; this.spread=false; }
    draw(){ drawPlane(this, CONFIG.player.image, '#4ec9f0', true); if(this.hasShield()){ drawShield(this); } }
    hasShield(){ return performance.now()<this.shieldUntil; }
    shoot(){ const t=performance.now(); if(t-this.lastShot < this.fireRate) return; this.lastShot=t; const pb = CONFIG.player.bullet||{speed:520}; play(pb.sound);
      if(this.spread){ bullets.push(new BulletImg(this.cx-3,this.y-10,6,16,-(pb.speed||520), false, pb.image, 0)); bullets.push(new BulletImg(this.cx-3,this.y-6,6,16,-(pb.speed||520), false, pb.image, -0.18)); bullets.push(new BulletImg(this.cx-3,this.y-6,6,16,-(pb.speed||520), false, pb.image, 0.18)); } else { bullets.push(new BulletImg(this.cx-3,this.y-10,6,16,-(pb.speed||520), false, pb.image, 0)); } }
    update(dt){ let vx=0, vy=0; if(keys['ArrowLeft']||keys['a']) vx=-1; if(keys['ArrowRight']||keys['d']) vx+=1; if(keys['ArrowUp']||keys['w']) vy=-1; if(keys['ArrowDown']||keys['s']) vy+=1; this.x = clamp(this.x + vx*this.speed*dt, 4, W-this.w-4); this.y = clamp(this.y + vy*this.speed*dt, 4, H-this.h-60); }
    applyPowerUp(p){ switch(p.type){ case 'rapid': this.fireRate = Math.max(80, (CONFIG.player.fireRate||220)*0.45); setTimer(this,'rapid',p.duration||8000,()=>this.fireRate=this.baseFireRate); break; case 'spread': this.spread = true; setTimer(this,'spread',p.duration||8000,()=>this.spread=false); break; case 'shield': this.shieldUntil = performance.now() + (p.duration||6000); break; case 'heal': this.hp = Math.min((CONFIG.player.hp||3), this.hp + (p.amount||1)); break; } }
  }

  class Enemy extends Entity{
    constructor(spec){ super(Math.random()*(W-40), -60, 40, 40); this.spec=spec; this.hp=spec.hp; this.vy=spec.speed; this.lastShot=0; }
    draw(){ drawPlane(this, this.spec.image, this.spec.color||'#88e', false); }
    update(dt){ this.y += this.vy*dt; if(this.y>H+60) this.dead=true; if(this.spec.fire && Math.random()<0.01){ const bSpec=this.spec.bullet||{}; play(bSpec.sound); enemyBullets.push(new BulletImg(this.cx-3,this.y+this.h,6,16,(bSpec.speed||180), true, bSpec.image, 0)); } }
  }

  class BulletImg extends Entity{ constructor(x,y,w,h,vy,isEnemy,img,angle){ super(x,y,w,h); this.vy=vy; this.isEnemy=isEnemy; this.img=img; this.angle=angle||0; this.vx = Math.sin(this.angle)*Math.abs(this.vy); } draw(){ if(this.img){ ctx.save(); ctx.translate(this.x+this.w/2,this.y+this.h/2); ctx.rotate(this.isEnemy?0: -Math.PI/2); ctx.drawImage(this.img,-this.w/2,-this.h/2,this.w,this.h); ctx.restore(); } else { ctx.fillStyle=this.isEnemy?'#ffa86b':'#6cf'; ctx.fillRect(this.x,this.y,this.w,this.h);} } update(dt){ this.x += this.vx*dt*0.25; this.y += this.vy*dt; if(this.y<-40||this.y>H+40||this.x<-40||this.x>W+40) this.dead=true; } }

  class PowerUp extends Entity{ constructor(spec){ super(Math.random()*(W-28), -32, 28, 28); this.spec=spec; this.vy=90; } draw(){ if(this.spec.image){ ctx.drawImage(this.spec.image, this.x, this.y, this.w, this.h); } else { drawPUFallback(this); } } update(dt){ this.y += this.vy*dt; if(this.y>H+40) this.dead=true; } }

  // ========= Drawing helpers =========
  function drawPlane(ent, img, color, isPlayer){ if(img){ ctx.drawImage(img, ent.x, ent.y, ent.w, ent.h); return; } ctx.save(); ctx.translate(ent.x, ent.y); ctx.fillStyle=color|| (isPlayer? '#4ec9f0':'#88e'); ctx.strokeStyle='#123'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(ent.w*0.5, 0); ctx.lineTo(ent.w, ent.h*0.65); ctx.lineTo(ent.w*0.7, ent.h*0.65); ctx.lineTo(ent.w*0.5, ent.h); ctx.lineTo(ent.w*0.3, ent.h*0.65); ctx.lineTo(0, ent.h*0.65); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.fillStyle = isPlayer? '#9df' : '#cfe8ff'; ctx.fillRect(ent.w*0.42, ent.h*0.2, ent.w*0.16, ent.h*0.22); ctx.restore(); }
  function drawShield(p){ ctx.save(); ctx.globalAlpha=0.35; ctx.fillStyle='#6ff'; ctx.beginPath(); ctx.arc(p.cx, p.cy, Math.max(p.w,p.h)*0.8, 0, Math.PI*2); ctx.fill(); ctx.restore(); }
  function drawPUFallback(pu){ ctx.save(); ctx.translate(pu.x,pu.y); ctx.fillStyle='#f7d774'; ctx.strokeStyle='#6a5300'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(pu.w/2,pu.h/2, pu.w/2, 0, Math.PI*2); ctx.fill(); ctx.stroke(); ctx.restore(); }

  // ========= Game State =========
  const player = new Player();
  const enemies=[]; const bullets=[]; const enemyBullets=[]; const powerUps=[];
  const WIN_SCORE = 2000; // <- puntaje para ganar
  const REDIRECT_URL = '/carga2.html'; // <- cambia aqu√≠ tu HTML de destino
  let lastEnemySpawn=0, lastPUSpawn=0; let score=0; let gameOver=false; let hasWon=false; let lt=performance.now();
  let winBtn = null; // se crea al ganar

  // ========= Input =========
  const keys={}; addEventListener('keydown', e=>{ keys[e.key]=true; if(e.key===' ') player.shoot(); if(e.key.toLowerCase()==='r'&&gameOver) restart(); });
  addEventListener('keyup', e=>{ keys[e.key]=false; });

  // Simple touch controls
  let touchId=null; C.addEventListener('touchstart',e=>{ const t=e.changedTouches[0]; touchId=t.identifier; moveTo(t.clientX,t.clientY); if(e.touches.length>1) player.shoot(); },{passive:true});
  C.addEventListener('touchmove',e=>{ for(const t of e.changedTouches){ if(t.identifier===touchId) moveTo(t.clientX,t.clientY); } },{passive:true});
  C.addEventListener('touchend',()=>{ touchId=null; });
  function moveTo(x,y){ const r=C.getBoundingClientRect(); player.x=clamp(x-r.left-player.w/2,4,W-player.w-4); player.y=clamp(y-r.top-player.h/2,4,H-player.h-60); }

  // ========= Loop =========
  function loop(){ const nt=performance.now(); const dt=(nt-lt)/1000; lt=nt; if(!gameOver && !hasWon){ update(dt); } draw(); requestAnimationFrame(loop); }

  function update(dt){
    const t=performance.now();
    // spawn enemigos
    if(t-lastEnemySpawn>(CONFIG.spawn.enemyInterval||900) && enemies.length<(CONFIG.spawn.maxEnemies||20)){
      lastEnemySpawn=t; const spec = CONFIG.enemies[Math.random()<0.5?0:(Math.random()<0.7?1:2)]; enemies.push(new Enemy(spec)); }
    // spawn powerups
    if(t-lastPUSpawn>(CONFIG.spawn.powerUpInterval||6000)){
      lastPUSpawn=t; const spec = CONFIG.powerUps[Math.floor(Math.random()*CONFIG.powerUps.length)]; powerUps.push(new PowerUp(spec)); }

    player.update(dt);
    bullets.forEach(b=>b.update(dt)); enemyBullets.forEach(b=>b.update(dt)); enemies.forEach(e=>e.update(dt)); powerUps.forEach(p=>p.update(dt));

    // colisiones: balas jugador vs enemigos
    for(const b of bullets){ if(b.dead) continue; for(const e of enemies){ if(e.dead) continue; if(b.intersects(e)){ b.dead=true; e.hp--; if(e.hp<=0){ e.dead=true; score+=e.spec.score||50; play(e.spec.deathSound); if(!hasWon && score>=WIN_SCORE){ triggerWin(); } } break; } } }

    // colisiones: balas enemigo vs jugador
    for(const eb of enemyBullets){ if(!eb.dead && eb.intersects(player)){ eb.dead=true; if(player.hasShield()){ /* absorbido */ } else { player.hp--; if(player.hp<=0){ gameOver=true; play(CONFIG.player.deathSound); } } } }

    // colisiones: enemigo vs jugador
    for(const e of enemies){ if(!e.dead && e.intersects(player)){ e.dead=true; if(player.hasShield()){ /* absorbido */ } else { player.hp--; if(player.hp<=0){ gameOver=true; play(CONFIG.player.deathSound); } } } }

    // colisiones: powerups
    for(const pu of powerUps){ if(!pu.dead && pu.intersects(player)){ pu.dead=true; player.applyPowerUp(pu.spec); } }

    prune(bullets); prune(enemyBullets); prune(enemies); prune(powerUps);
  }
  function prune(arr){ for(let i=arr.length-1;i>=0;i--) if(arr[i].dead) arr.splice(i,1); }

  function draw(){
    drawStars();
    // HUD bar
    ctx.fillStyle='rgba(0,0,0,.35)'; ctx.fillRect(0,0,W,34);
    ctx.fillStyle='#cfe8ff'; ctx.font='bold 14px system-ui,Arial'; ctx.textAlign='left';
    ctx.fillText(`Puntos: ${score}`, 10, 22);
    ctx.textAlign='right';
    ctx.fillText(`Vidas: ${Math.max(0,player.hp)}`, W-10, 22);

    // Power-up badges (derecha)
    ctx.textAlign='right'; ctx.font='12px system-ui,Arial';
    let y=50; if(player.spread){ ctx.fillText('SPREAD', W-10, y); y+=16; }
    if(player.fireRate < player.baseFireRate){ ctx.fillText('RAPID', W-10, y); y+=16; }
    if(player.hasShield()){ ctx.fillText('SHIELD', W-10, y); y+=16; }

    player.draw(); bullets.forEach(b=>b.draw()); enemyBullets.forEach(b=>b.draw()); enemies.forEach(e=>e.draw()); powerUps.forEach(p=>p.draw());

    if(gameOver){ ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#fff'; ctx.font='bold 28px system-ui,Arial'; ctx.textAlign='center'; ctx.fillText('GAME OVER', W/2, H/2-10); ctx.font='16px system-ui,Arial'; ctx.fillText('Presiona R para reiniciar', W/2, H/2+20); if(winBtn) winBtn.classList.remove('show'); return; }

    if(hasWon){
      // capa de victoria
      ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(0,0,W,H);
      ctx.textAlign='center';
      // avi√≥n grande
      if(CONFIG.player.image){
        const iw=220, ih=260; ctx.drawImage(CONFIG.player.image, (W-iw)/2, H*0.24, iw, ih);
      } else {
        const dummy = new Entity(W/2-110, H*0.24, 220, 260); drawPlane(dummy, null, '#4ec9f0', true);
      }
      ctx.fillStyle='#fff'; ctx.font='bold 30px system-ui,Arial';
      ctx.fillText('Lo Lograste!!', W/2, H*0.24 + 400);
      if(winBtn) winBtn.classList.add('show');
      return;
    } else {
      if(winBtn) winBtn.classList.remove('show');
    }
  }

  // fondo estrellas
  const stars = Array.from({length:DEFAULTS.background.stars},()=>({x:Math.random()*W,y:Math.random()*H,s:Math.random()*2+0.5,v:Math.random()*40+20}));
  function drawStars(){ ctx.fillStyle='#0a1430'; ctx.fillRect(0,0,W,H); ctx.fillStyle='#e6f2ff'; for(const st of stars){ ctx.globalAlpha=0.6; ctx.fillRect(st.x,st.y,st.s,st.s); st.y+=st.v/60; if(st.y>H){ st.y=-2; st.x=Math.random()*W; } } ctx.globalAlpha=1; }

  function restart(){ enemies.length=0; bullets.length=0; enemyBullets.length=0; powerUps.length=0; score=0; player.resetStats(); player.x=W/2-20; player.y=H-110; gameOver=false; hasWon=false; if(winBtn) winBtn.classList.remove('show');playBackgroundMusic(); }

function triggerWin() {
  hasWon = true;
  if (bgMusic) bgMusic.pause(); // detener m√∫sica fondo
  playMusic(CONFIG.musicVictory);
  ensureWinButton();
}

  function ensureWinButton(){ if(winBtn) return; winBtn = document.createElement('a'); winBtn.id='winBtn'; winBtn.className='winbtn'; winBtn.textContent='Continuar'; winBtn.href = REDIRECT_URL; document.body.appendChild(winBtn); }

  // --- inicio ---
  
// --- inicio ---
(async function start(){
  await applyConfigFromBackend();
  await playBackgroundMusic(); // m√∫sica de fondo
  loop();
})();

  </script>
</body>
</html>

